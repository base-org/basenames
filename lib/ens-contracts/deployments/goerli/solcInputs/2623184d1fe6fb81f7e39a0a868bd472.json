{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "contracts/resolvers/profiles/IABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IABIResolver {\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view returns (uint256, bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "contracts/resolvers/profiles/IContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IContentHashResolver {\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IDNSRecordResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSRecordResolver {\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\n    event DNSRecordChanged(\n        bytes32 indexed node,\n        bytes name,\n        uint16 resource,\n        bytes record\n    );\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IDNSZoneResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSZoneResolver {\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\n    event DNSZonehashChanged(\n        bytes32 indexed node,\n        bytes lastzonehash,\n        bytes zonehash\n    );\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IInterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IInterfaceResolver {\n    event InterfaceChanged(\n        bytes32 indexed node,\n        bytes4 indexed interfaceID,\n        address implementer\n    );\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view returns (address);\n}\n"
    },
    "contracts/resolvers/profiles/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "contracts/resolvers/profiles/IPubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IPubkeyResolver {\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n}\n"
    },
    "contracts/resolvers/profiles/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n}\n"
    },
    "contracts/resolvers/Resolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"./profiles/IABIResolver.sol\";\nimport \"./profiles/IAddressResolver.sol\";\nimport \"./profiles/IAddrResolver.sol\";\nimport \"./profiles/IContentHashResolver.sol\";\nimport \"./profiles/IDNSRecordResolver.sol\";\nimport \"./profiles/IDNSZoneResolver.sol\";\nimport \"./profiles/IInterfaceResolver.sol\";\nimport \"./profiles/INameResolver.sol\";\nimport \"./profiles/IPubkeyResolver.sol\";\nimport \"./profiles/ITextResolver.sol\";\nimport \"./profiles/IExtendedResolver.sol\";\n\n/**\n * A generic resolver interface which includes all the functions including the ones deprecated\n */\ninterface Resolver is\n    IERC165,\n    IABIResolver,\n    IAddressResolver,\n    IAddrResolver,\n    IContentHashResolver,\n    IDNSRecordResolver,\n    IDNSZoneResolver,\n    IInterfaceResolver,\n    INameResolver,\n    IPubkeyResolver,\n    ITextResolver,\n    IExtendedResolver\n{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n"
    },
    "contracts/utils/HexUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /**\n     * @dev Attempts to parse bytes32 from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexStringToBytes32(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes32 r, bool valid) {\n        valid = true;\n        assembly {\n            // check that the index to read to is not past the end of the string\n            if gt(lastIdx, mload(str)) {\n                revert(0, 0)\n            }\n\n            function getHex(c) -> ascii {\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0xff\n            }\n\n            let ptr := add(str, 32)\n            for {\n                let i := idx\n            } lt(i, lastIdx) {\n                i := add(i, 2)\n            } {\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                // if either byte is invalid, set invalid and break loop\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n                    valid := false\n                    break\n                }\n                let combined := or(shl(4, byte1), byte2)\n                r := or(shl(8, r), combined)\n            }\n        }\n    }\n\n    /**\n     * @dev Attempts to parse an address from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n}\n"
    },
    "contracts/utils/LowLevelCallUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nlibrary LowLevelCallUtils {\n    using Address for address;\n\n    /**\n     * @dev Makes a static call to the specified `target` with `data`. Return data can be fetched with\n     *      `returnDataSize` and `readReturnData`.\n     * @param target The address to staticcall.\n     * @param data The data to pass to the call.\n     * @return success True if the call succeeded, or false if it reverts.\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data\n    ) internal view returns (bool success) {\n        require(\n            target.isContract(),\n            \"LowLevelCallUtils: static call to non-contract\"\n        );\n        assembly {\n            success := staticcall(\n                gas(),\n                target,\n                add(data, 32),\n                mload(data),\n                0,\n                0\n            )\n        }\n    }\n\n    /**\n     * @dev Returns the size of the return data of the most recent external call.\n     */\n    function returnDataSize() internal pure returns (uint256 len) {\n        assembly {\n            len := returndatasize()\n        }\n    }\n\n    /**\n     * @dev Reads return data from the most recent external call.\n     * @param offset Offset into the return data.\n     * @param length Number of bytes to return.\n     */\n    function readReturnData(\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (bytes memory data) {\n        data = new bytes(length);\n        assembly {\n            returndatacopy(add(data, 32), offset, length)\n        }\n    }\n\n    /**\n     * @dev Reverts with the return data from the most recent external call.\n     */\n    function propagateRevert() internal pure {\n        assembly {\n            returndatacopy(0, 0, returndatasize())\n            revert(0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/utils/NameEncoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {BytesUtils} from \"../wrapper/BytesUtils.sol\";\n\nlibrary NameEncoder {\n    using BytesUtils for bytes;\n\n    function dnsEncodeName(\n        string memory name\n    ) internal pure returns (bytes memory dnsName, bytes32 node) {\n        uint8 labelLength = 0;\n        bytes memory bytesName = bytes(name);\n        uint256 length = bytesName.length;\n        dnsName = new bytes(length + 2);\n        node = 0;\n        if (length == 0) {\n            dnsName[0] = 0;\n            return (dnsName, node);\n        }\n\n        // use unchecked to save gas since we check for an underflow\n        // and we check for the length before the loop\n        unchecked {\n            for (uint256 i = length - 1; i >= 0; i--) {\n                if (bytesName[i] == \".\") {\n                    dnsName[i + 1] = bytes1(labelLength);\n                    node = keccak256(\n                        abi.encodePacked(\n                            node,\n                            bytesName.keccak(i + 1, labelLength)\n                        )\n                    );\n                    labelLength = 0;\n                } else {\n                    labelLength += 1;\n                    dnsName[i + 1] = bytesName[i];\n                }\n                if (i == 0) {\n                    break;\n                }\n            }\n        }\n\n        node = keccak256(\n            abi.encodePacked(node, bytesName.keccak(0, labelLength))\n        );\n\n        dnsName[0] = bytes1(labelLength);\n        return (dnsName, node);\n    }\n}\n"
    },
    "contracts/utils/UniversalResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LowLevelCallUtils} from \"./LowLevelCallUtils.sol\";\nimport {ENS} from \"../registry/ENS.sol\";\nimport {IExtendedResolver} from \"../resolvers/profiles/IExtendedResolver.sol\";\nimport {Resolver, INameResolver, IAddrResolver} from \"../resolvers/Resolver.sol\";\nimport {NameEncoder} from \"./NameEncoder.sol\";\nimport {BytesUtils} from \"../wrapper/BytesUtils.sol\";\nimport {HexUtils} from \"./HexUtils.sol\";\n\nerror OffchainLookup(\n    address sender,\n    string[] urls,\n    bytes callData,\n    bytes4 callbackFunction,\n    bytes extraData\n);\n\nstruct MulticallData {\n    bytes name;\n    bytes[] data;\n    string[] gateways;\n    bytes4 callbackFunction;\n    bool isWildcard;\n    address resolver;\n    bytes metaData;\n    bool[] failures;\n}\n\nstruct OffchainLookupCallData {\n    address sender;\n    string[] urls;\n    bytes callData;\n}\n\nstruct OffchainLookupExtraData {\n    bytes4 callbackFunction;\n    bytes data;\n}\n\ninterface BatchGateway {\n    function query(\n        OffchainLookupCallData[] memory data\n    ) external returns (bool[] memory failures, bytes[] memory responses);\n}\n\n/**\n * The Universal Resolver is a contract that handles the work of resolving a name entirely onchain,\n * making it possible to make a single smart contract call to resolve an ENS name.\n */\ncontract UniversalResolver is ERC165, Ownable {\n    using Address for address;\n    using NameEncoder for string;\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n\n    string[] public batchGatewayURLs;\n    ENS public immutable registry;\n\n    constructor(address _registry, string[] memory _urls) {\n        registry = ENS(_registry);\n        batchGatewayURLs = _urls;\n    }\n\n    function setGatewayURLs(string[] memory _urls) public onlyOwner {\n        batchGatewayURLs = _urls;\n    }\n\n    /**\n     * @dev Performs ENS name resolution for the supplied name and resolution data.\n     * @param name The name to resolve, in normalised and DNS-encoded form.\n     * @param data The resolution data, as specified in ENSIP-10.\n     * @return The result of resolving the name.\n     */\n    function resolve(\n        bytes calldata name,\n        bytes memory data\n    ) external view returns (bytes memory, address) {\n        return\n            _resolveSingle(\n                name,\n                data,\n                batchGatewayURLs,\n                this.resolveSingleCallback.selector,\n                \"\"\n            );\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes[] memory data\n    ) external view returns (bytes[] memory, address) {\n        return resolve(name, data, batchGatewayURLs);\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes memory data,\n        string[] memory gateways\n    ) external view returns (bytes memory, address) {\n        return\n            _resolveSingle(\n                name,\n                data,\n                gateways,\n                this.resolveSingleCallback.selector,\n                \"\"\n            );\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes[] memory data,\n        string[] memory gateways\n    ) public view returns (bytes[] memory, address) {\n        return\n            _resolve(name, data, gateways, this.resolveCallback.selector, \"\");\n    }\n\n    function _resolveSingle(\n        bytes calldata name,\n        bytes memory data,\n        string[] memory gateways,\n        bytes4 callbackFunction,\n        bytes memory metaData\n    ) public view returns (bytes memory, address) {\n        bytes[] memory dataArr = new bytes[](1);\n        dataArr[0] = data;\n        (bytes[] memory results, address resolver) = _resolve(\n            name,\n            dataArr,\n            gateways,\n            callbackFunction,\n            metaData\n        );\n        return (results[0], resolver);\n    }\n\n    function _resolve(\n        bytes calldata name,\n        bytes[] memory data,\n        string[] memory gateways,\n        bytes4 callbackFunction,\n        bytes memory metaData\n    ) internal view returns (bytes[] memory results, address resolverAddress) {\n        (Resolver resolver, , uint256 finalOffset) = findResolver(name);\n        resolverAddress = address(resolver);\n        if (resolverAddress == address(0)) {\n            return (results, address(0));\n        }\n\n        bool isWildcard = finalOffset != 0;\n\n        results = _multicall(\n            MulticallData(\n                name,\n                data,\n                gateways,\n                callbackFunction,\n                isWildcard,\n                resolverAddress,\n                metaData,\n                new bool[](data.length)\n            )\n        );\n    }\n\n    function reverse(\n        bytes calldata reverseName\n    ) external view returns (string memory, address, address, address) {\n        return reverse(reverseName, batchGatewayURLs);\n    }\n\n    /**\n     * @dev Performs ENS name reverse resolution for the supplied reverse name.\n     * @param reverseName The reverse name to resolve, in normalised and DNS-encoded form. e.g. b6E040C9ECAaE172a89bD561c5F73e1C48d28cd9.addr.reverse\n     * @return The resolved name, the resolved address, the reverse resolver address, and the resolver address.\n     */\n    function reverse(\n        bytes calldata reverseName,\n        string[] memory gateways\n    ) public view returns (string memory, address, address, address) {\n        bytes memory encodedCall = abi.encodeCall(\n            INameResolver.name,\n            reverseName.namehash(0)\n        );\n        (\n            bytes memory resolvedReverseData,\n            address reverseResolverAddress\n        ) = _resolveSingle(\n                reverseName,\n                encodedCall,\n                gateways,\n                this.reverseCallback.selector,\n                \"\"\n            );\n\n        return\n            getForwardDataFromReverse(\n                resolvedReverseData,\n                reverseResolverAddress,\n                gateways\n            );\n    }\n\n    function getForwardDataFromReverse(\n        bytes memory resolvedReverseData,\n        address reverseResolverAddress,\n        string[] memory gateways\n    ) internal view returns (string memory, address, address, address) {\n        string memory resolvedName = abi.decode(resolvedReverseData, (string));\n\n        (bytes memory encodedName, bytes32 namehash) = resolvedName\n            .dnsEncodeName();\n\n        bytes memory encodedCall = abi.encodeCall(IAddrResolver.addr, namehash);\n        bytes memory metaData = abi.encode(\n            resolvedName,\n            reverseResolverAddress\n        );\n        (bytes memory resolvedData, address resolverAddress) = this\n            ._resolveSingle(\n                encodedName,\n                encodedCall,\n                gateways,\n                this.reverseCallback.selector,\n                metaData\n            );\n\n        address resolvedAddress = abi.decode(resolvedData, (address));\n\n        return (\n            resolvedName,\n            resolvedAddress,\n            reverseResolverAddress,\n            resolverAddress\n        );\n    }\n\n    function resolveSingleCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes memory, address) {\n        (bytes[] memory results, address resolver, , ) = _resolveCallback(\n            response,\n            extraData,\n            this.resolveSingleCallback.selector\n        );\n        return (results[0], resolver);\n    }\n\n    function resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes[] memory, address) {\n        (bytes[] memory results, address resolver, , ) = _resolveCallback(\n            response,\n            extraData,\n            this.resolveCallback.selector\n        );\n        return (results, resolver);\n    }\n\n    function reverseCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (string memory, address, address, address) {\n        (\n            bytes[] memory resolvedData,\n            address resolverAddress,\n            string[] memory gateways,\n            bytes memory metaData\n        ) = _resolveCallback(\n                response,\n                extraData,\n                this.reverseCallback.selector\n            );\n\n        if (metaData.length > 0) {\n            (string memory resolvedName, address reverseResolverAddress) = abi\n                .decode(metaData, (string, address));\n            address resolvedAddress = abi.decode(resolvedData[0], (address));\n            return (\n                resolvedName,\n                resolvedAddress,\n                reverseResolverAddress,\n                resolverAddress\n            );\n        }\n\n        return\n            getForwardDataFromReverse(\n                resolvedData[0],\n                resolverAddress,\n                gateways\n            );\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IExtendedResolver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData,\n        bytes4 callbackFunction\n    )\n        internal\n        view\n        returns (bytes[] memory, address, string[] memory, bytes memory)\n    {\n        MulticallData memory multicallData;\n        multicallData.callbackFunction = callbackFunction;\n        (bool[] memory failures, bytes[] memory responses) = abi.decode(\n            response,\n            (bool[], bytes[])\n        );\n        OffchainLookupExtraData[] memory extraDatas;\n        (\n            multicallData.isWildcard,\n            multicallData.resolver,\n            multicallData.gateways,\n            multicallData.metaData,\n            extraDatas\n        ) = abi.decode(\n            extraData,\n            (bool, address, string[], bytes, OffchainLookupExtraData[])\n        );\n        require(responses.length <= extraDatas.length);\n        multicallData.data = new bytes[](extraDatas.length);\n        multicallData.failures = new bool[](extraDatas.length);\n        uint256 offchainCount = 0;\n        for (uint256 i = 0; i < extraDatas.length; i++) {\n            if (extraDatas[i].callbackFunction == bytes4(0)) {\n                // This call did not require an offchain lookup; use the previous input data.\n                multicallData.data[i] = extraDatas[i].data;\n            } else {\n                if (failures[offchainCount]) {\n                    multicallData.failures[i] = true;\n                    multicallData.data[i] = responses[offchainCount];\n                } else {\n                    multicallData.data[i] = abi.encodeWithSelector(\n                        extraDatas[i].callbackFunction,\n                        responses[offchainCount],\n                        extraDatas[i].data\n                    );\n                }\n                offchainCount = offchainCount + 1;\n            }\n        }\n\n        return (\n            _multicall(multicallData),\n            multicallData.resolver,\n            multicallData.gateways,\n            multicallData.metaData\n        );\n    }\n\n    /**\n     * @dev Makes a call to `target` with `data`. If the call reverts with an `OffchainLookup` error, wraps\n     *      the error with the data necessary to continue the request where it left off.\n     * @param target The address to call.\n     * @param data The data to call `target` with.\n     * @return offchain Whether the call reverted with an `OffchainLookup` error.\n     * @return returnData If `target` did not revert, contains the return data from the call to `target`. Otherwise, contains a `OffchainLookupCallData` struct.\n     * @return extraData If `target` did not revert, is empty. Otherwise, contains a `OffchainLookupExtraData` struct.\n     * @return result Whether the call succeeded.\n     */\n    function callWithOffchainLookupPropagation(\n        address target,\n        bytes memory data\n    )\n        internal\n        view\n        returns (\n            bool offchain,\n            bytes memory returnData,\n            OffchainLookupExtraData memory extraData,\n            bool result\n        )\n    {\n        result = LowLevelCallUtils.functionStaticCall(address(target), data);\n        uint256 size = LowLevelCallUtils.returnDataSize();\n\n        if (result) {\n            return (\n                false,\n                LowLevelCallUtils.readReturnData(0, size),\n                extraData,\n                true\n            );\n        }\n\n        // Failure\n        if (size >= 4) {\n            bytes memory errorId = LowLevelCallUtils.readReturnData(0, 4);\n            // Offchain lookup. Decode the revert message and create our own that nests it.\n            bytes memory revertData = LowLevelCallUtils.readReturnData(\n                4,\n                size - 4\n            );\n            if (bytes4(errorId) == OffchainLookup.selector) {\n                (\n                    address wrappedSender,\n                    string[] memory wrappedUrls,\n                    bytes memory wrappedCallData,\n                    bytes4 wrappedCallbackFunction,\n                    bytes memory wrappedExtraData\n                ) = abi.decode(\n                        revertData,\n                        (address, string[], bytes, bytes4, bytes)\n                    );\n                if (wrappedSender == target) {\n                    returnData = abi.encode(\n                        OffchainLookupCallData(\n                            wrappedSender,\n                            wrappedUrls,\n                            wrappedCallData\n                        )\n                    );\n                    extraData = OffchainLookupExtraData(\n                        wrappedCallbackFunction,\n                        wrappedExtraData\n                    );\n                    return (true, returnData, extraData, false);\n                }\n            } else {\n                returnData = revertData;\n                return (false, returnData, extraData, false);\n            }\n        }\n    }\n\n    /**\n     * @dev Finds a resolver by recursively querying the registry, starting at the longest name and progressively\n     *      removing labels until it finds a result.\n     * @param name The name to resolve, in DNS-encoded and normalised form.\n     * @return resolver The Resolver responsible for this name.\n     * @return namehash The namehash of the full name.\n     * @return finalOffset The offset of the first label with a resolver.\n     */\n    function findResolver(\n        bytes calldata name\n    ) public view returns (Resolver, bytes32, uint256) {\n        (\n            address resolver,\n            bytes32 namehash,\n            uint256 finalOffset\n        ) = findResolver(name, 0);\n        return (Resolver(resolver), namehash, finalOffset);\n    }\n\n    function findResolver(\n        bytes calldata name,\n        uint256 offset\n    ) internal view returns (address, bytes32, uint256) {\n        uint256 labelLength = uint256(uint8(name[offset]));\n        if (labelLength == 0) {\n            return (address(0), bytes32(0), offset);\n        }\n        uint256 nextLabel = offset + labelLength + 1;\n        bytes32 labelHash;\n        if (\n            labelLength == 66 &&\n            // 0x5b == '['\n            name[offset + 1] == 0x5b &&\n            // 0x5d == ']'\n            name[nextLabel - 1] == 0x5d\n        ) {\n            // Encrypted label\n            (labelHash, ) = bytes(name[offset + 2:nextLabel - 1])\n                .hexStringToBytes32(0, 64);\n        } else {\n            labelHash = keccak256(name[offset + 1:nextLabel]);\n        }\n        (\n            address parentresolver,\n            bytes32 parentnode,\n            uint256 parentoffset\n        ) = findResolver(name, nextLabel);\n        bytes32 node = keccak256(abi.encodePacked(parentnode, labelHash));\n        address resolver = registry.resolver(node);\n        if (resolver != address(0)) {\n            return (resolver, node, offset);\n        }\n        return (parentresolver, node, parentoffset);\n    }\n\n    function _hasExtendedResolver(\n        address resolver\n    ) internal view returns (bool) {\n        try\n            Resolver(resolver).supportsInterface{gas: 50000}(\n                type(IExtendedResolver).interfaceId\n            )\n        returns (bool supported) {\n            return supported;\n        } catch {\n            return false;\n        }\n    }\n\n    function _multicall(\n        MulticallData memory multicallData\n    ) internal view returns (bytes[] memory results) {\n        uint256 length = multicallData.data.length;\n        uint256 offchainCount = 0;\n        OffchainLookupCallData[]\n            memory callDatas = new OffchainLookupCallData[](length);\n        OffchainLookupExtraData[]\n            memory extraDatas = new OffchainLookupExtraData[](length);\n        results = new bytes[](length);\n        bool isCallback = multicallData.name.length == 0;\n        bool hasExtendedResolver = _hasExtendedResolver(multicallData.resolver);\n\n        require(\n            !multicallData.isWildcard || hasExtendedResolver,\n            \"UniversalResolver: Wildcard on non-extended resolvers is not supported\"\n        );\n\n        for (uint256 i = 0; i < length; i++) {\n            bytes memory item = multicallData.data[i];\n            bool failure = multicallData.failures[i];\n            if (failure) {\n                results[i] = item;\n                continue;\n            }\n            if (!isCallback && hasExtendedResolver) {\n                item = abi.encodeCall(\n                    IExtendedResolver.resolve,\n                    (multicallData.name, item)\n                );\n            }\n            (\n                bool offchain,\n                bytes memory returnData,\n                OffchainLookupExtraData memory extraData,\n                bool success\n            ) = callWithOffchainLookupPropagation(multicallData.resolver, item);\n\n            if (offchain) {\n                callDatas[offchainCount] = abi.decode(\n                    returnData,\n                    (OffchainLookupCallData)\n                );\n                extraDatas[i] = extraData;\n                offchainCount += 1;\n                continue;\n            }\n\n            if (success && hasExtendedResolver) {\n                // if this is a successful resolve() call, unwrap the result\n                returnData = abi.decode(returnData, (bytes));\n            }\n            results[i] = returnData;\n            extraDatas[i].data = multicallData.data[i];\n        }\n\n        if (offchainCount == 0) {\n            return results;\n        }\n\n        // Trim callDatas if offchain data exists\n        assembly {\n            mstore(callDatas, offchainCount)\n        }\n\n        revert OffchainLookup(\n            address(this),\n            multicallData.gateways,\n            abi.encodeWithSelector(BatchGateway.query.selector, callDatas),\n            multicallData.callbackFunction,\n            abi.encode(\n                multicallData.isWildcard,\n                multicallData.resolver,\n                multicallData.gateways,\n                multicallData.metaData,\n                extraDatas\n            )\n        );\n    }\n}\n"
    },
    "contracts/wrapper/BytesUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nlibrary BytesUtils {\n    /*\n     * @dev Returns the keccak-256 hash of a byte range.\n     * @param self The byte string to hash.\n     * @param offset The position to start hashing at.\n     * @param len The number of bytes to hash.\n     * @return The hash of the byte range.\n     */\n    function keccak(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /**\n     * @dev Returns the ENS namehash of a DNS-encoded name.\n     * @param self The DNS-encoded name to hash.\n     * @param offset The offset at which to start hashing.\n     * @return The namehash of the name.\n     */\n    function namehash(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\n        if (labelhash == bytes32(0)) {\n            require(offset == self.length - 1, \"namehash: Junk at end of name\");\n            return bytes32(0);\n        }\n        return\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\n    }\n\n    /**\n     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\n     * @param self The byte string to read a label from.\n     * @param idx The index to read a label at.\n     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\n     * @return newIdx The index of the start of the next label.\n     */\n    function readLabel(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\n        require(idx < self.length, \"readLabel: Index out of bounds\");\n        uint256 len = uint256(uint8(self[idx]));\n        if (len > 0) {\n            labelhash = keccak(self, idx + 1, len);\n        } else {\n            labelhash = bytes32(0);\n        }\n        newIdx = idx + len + 1;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1300
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}